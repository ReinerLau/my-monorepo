# 2023-04-23

## 1. 前言

今天是该项目启动的第一天，记录一下，给自己立个 flag，做完我就润

## 2. 为什么使用 monorepo 架构

最开始是逛各种社区，看到很多文章都出现了这个字眼，出于好奇了解了一下，原来是一种架构，而且 Vue3 和 Element-plus 都是用这个种架构搭建的。换作一年前只知道写业务代码的我看到“架构”类似字眼，我肯定第一时间关掉窗口不会继续深入，不过自从当了组长，为了规范团队，提升工作效率，我也倒逼自己输入了很多工程化相关的东西并输出给组员，重点是比写业务代码有意思很多，经过这段时间的历练，我的知识体系和认知维度确实有进一步的提升，对于如何分析问题、解决问题有一些经验流程上的积累，所以现在看到架构这些并没有太多的恐惧倒还挺感兴趣的，了解架构会有一种掌握全局的安全感，最重要的是我也想搭建一个属于自己的组件库了，虽然相比同龄后辈感觉有点慢，但开始总比没有开始强。

### 2.1 什么是 monorepo？

#### 2.1.1 multirepo

先看以往我们是怎么管理多个项目的，一个项目一个 git 仓库对吧？这样的管理方式会有以下问题：

假设现在我们有两个项目对应两个仓库 A 和 B，A 和 B 都有某个相同的函数逻辑，如果不想办法将该函数抽离出来，日后如果需要修改这个函数的逻辑，我们还得使用 cv （复制粘贴）大法，分别去手动修改 A 和 B 调用该函数的地方，万一不只 A 和 B，有更多的项目，就容易造成改了这，忘了那的结果，那绝对是噩梦，太不程序员了。

为了解决上面的问题，我们可以将函数作为工具函数抽离成一个包发布到 npm 上，假设这个包叫 C，A 和 B 两个项目只要引入 C 包就好，这个方法虽然少了大部分代码复制粘贴，但还是存在一处代码改动，需要手动更新多个项目依赖的问题，而且更新代码的流程很长，比如整个更新流程是这样的：

1. 修改 C 包
2. 提交代码
3. 发布到 npm 上
4. 手动修改项目 A 依赖 C 包的版本并重新下载测试
5. 手动修改项目 B 依赖 C 包的版本并重新下载测试
6. 测试完成，A 和 B 准备好发布

#### 2.1.2 monorepo

相比用多个仓库管理多个项目，monorepo 将相关的项目全部整合到一个仓库中，类似下面的结构：

```
.
├── apps/
│   ├── project-a/
│   │   └── package.json
│   └── project-b/
│       └── package.json
├── packages/
│   └── package-c/
│       └── package.json
└── package.json
```

这种架构有以下好处：

项目 A 和 B 永远共用 C 包的最新代码，不关注其版本，提升了开发效率

```json
{
  "dependencies": {
    "package-c": "workspace:*"
  }
}
```

这时候更新代码的流程就是这样的：

1. 修改 C 包
2. 测试完成，A 和 B 准备好发布

多个项目间没有重复多余的提交信息，只需要一条提交信息。

此外根目录还有一个额外的 package.json 文件，有以下好处：

- 可以指定项目间共用的依赖和配置
- 可以同时给所有项目执行相同的命令，不用独立某个项目目录执行
- 描述整个 monorepo 项目的信息




